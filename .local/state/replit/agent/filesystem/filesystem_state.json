{"file_contents":{"app.py":{"content":"from flask import Flask, request, render_template, jsonify, send_from_directory\nimport os\nimport json\nimport numpy as np\nimport xarray as xr\nimport pandas as pd\nfrom werkzeug.utils import secure_filename\nimport folium\nfrom branca.element import MacroElement\nimport plotly.graph_objs as go\nimport plotly.utils\n\napp = Flask(__name__)\napp.config['SECRET_KEY'] = os.environ.get('SESSION_SECRET', 'dev-secret-key')\napp.config['UPLOAD_FOLDER'] = 'uploads'\napp.config['MAX_CONTENT_LENGTH'] = 100 * 1024 * 1024  # 100MB max file size\n\n# Ensure upload folder exists\nos.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)\n\n# Store current NetCDF data globally (in production, use proper session management)\ncurrent_dataset = None\ncurrent_filename = None\n\n\ndef allowed_file(filename):\n    \"\"\"Check if file has allowed extension\"\"\"\n    return '.' in filename and filename.rsplit('.', 1)[1].lower() == 'nc'\n\n\ndef convert_numpy_types(obj):\n    \"\"\"Recursively convert numpy types to Python native types for JSON serialization\"\"\"\n    if isinstance(obj, np.integer):\n        return int(obj)\n    elif isinstance(obj, np.floating):\n        return float(obj)\n    elif isinstance(obj, np.ndarray):\n        return obj.tolist()\n    elif isinstance(obj, dict):\n        return {k: convert_numpy_types(v) for k, v in obj.items()}\n    elif isinstance(obj, list):\n        return [convert_numpy_types(item) for item in obj]\n    elif isinstance(obj, tuple):\n        return tuple(convert_numpy_types(item) for item in obj)\n    else:\n        return obj\n\n\ndef extract_netcdf_info(filepath):\n    \"\"\"Extract basic information from NetCDF file\"\"\"\n    try:\n        ds = xr.open_dataset(filepath)\n        \n        # Get coordinate information\n        coords = {}\n        for dim in ds.dims:\n            if dim in ds.coords:\n                coords[dim] = {\n                    'min': float(ds.coords[dim].min().values),\n                    'max': float(ds.coords[dim].max().values),\n                    'size': int(ds.sizes[dim])\n                }\n        \n        # Get variable information\n        variables = {}\n        for var in ds.data_vars:\n            # Convert attributes to ensure JSON serializable\n            attrs = dict(ds[var].attrs) if hasattr(ds[var], 'attrs') else {}\n            safe_attrs = convert_numpy_types(attrs)\n            \n            variables[var] = {\n                'dims': list(ds[var].dims),\n                'shape': [int(x) for x in ds[var].shape],\n                'attrs': safe_attrs\n            }\n        \n        # Convert global attributes to ensure JSON serializable\n        global_attrs = dict(ds.attrs) if hasattr(ds, 'attrs') else {}\n        safe_global_attrs = convert_numpy_types(global_attrs)\n        \n        return {\n            'coords': coords,\n            'variables': variables,\n            'global_attrs': safe_global_attrs,\n            'success': True\n        }\n    except Exception as e:\n        return {'success': False, 'error': str(e)}\n\n\ndef create_coverage_map(ds):\n    \"\"\"Create a folium map showing the data coverage area\"\"\"\n    # Find latitude and longitude coordinates\n    lat_var = None\n    lon_var = None\n    \n    for coord in ds.coords:\n        coord_lower = str(coord).lower()\n        if 'lat' in coord_lower:\n            lat_var = coord\n        elif 'lon' in coord_lower:\n            lon_var = coord\n    \n    if not lat_var or not lon_var:\n        return None\n    \n    lats = ds.coords[lat_var].values\n    lons = ds.coords[lon_var].values\n    \n    # Create map centered on the data\n    center_lat = float(np.mean(lats))\n    center_lon = float(np.mean(lons))\n    \n    # Create the map\n    m = folium.Map(location=[center_lat, center_lon], zoom_start=6)\n    \n    # Add a rectangle showing the data bounds\n    bounds = [\n        [float(np.min(lats)), float(np.min(lons))],\n        [float(np.max(lats)), float(np.max(lons))]\n    ]\n    \n    folium.Rectangle(\n        bounds=bounds,\n        color='red',\n        fill=True,\n        fillOpacity=0.2,\n        popup='Data Coverage Area'\n    ).add_to(m)\n    \n    # Add clickable markers for each grid point\n    for lat in lats:\n        for lon in lons:\n            marker = folium.CircleMarker(\n                location=[float(lat), float(lon)],\n                radius=8,\n                popup=f'Grid Point<br>Lat: {float(lat):.4f}<br>Lon: {float(lon):.4f}<br>Click for time series',\n                color='blue',\n                fill=True,\n                fillColor='lightblue',\n                fillOpacity=0.8,\n                weight=2\n            )\n            marker.add_to(m)\n            \n            # Add hover tooltip\n            marker.add_child(folium.Tooltip(f'Lat: {float(lat):.4f}, Lon: {float(lon):.4f}'))\n    \n    # Add click handler for point selection with grid snapping\n    # Convert coordinate arrays to lists for JavaScript\n    lat_values = [float(lat) for lat in lats]\n    lon_values = [float(lon) for lon in lons]\n    \n    click_script = f\"\"\"\n    <script>\n    var mapObj = {m.get_name()};\n    var gridLats = {lat_values};\n    var gridLons = {lon_values};\n    \n    // Function to find nearest grid point\n    function findNearestGridPoint(clickLat, clickLon) {{\n        let minDist = Infinity;\n        let nearestLat = clickLat;\n        let nearestLon = clickLon;\n        \n        for (let lat of gridLats) {{\n            for (let lon of gridLons) {{\n                let dist = Math.sqrt(Math.pow(lat - clickLat, 2) + Math.pow(lon - clickLon, 2));\n                if (dist < minDist) {{\n                    minDist = dist;\n                    nearestLat = lat;\n                    nearestLon = lon;\n                }}\n            }}\n        }}\n        return {{lat: nearestLat, lon: nearestLon}};\n    }}\n    \n    mapObj.on('click', function(e) {{\n        const clickLat = e.latlng.lat;\n        const clickLng = e.latlng.lng;\n        \n        // Find nearest grid point\n        const nearest = findNearestGridPoint(clickLat, clickLng);\n        \n        // Remove previous selection markers\n        mapObj.eachLayer(function(layer) {{\n            if (layer.options && layer.options.className === 'selected-point') {{\n                mapObj.removeLayer(layer);\n            }}\n        }});\n        \n        // Add selection marker at nearest grid point\n        L.circleMarker([nearest.lat, nearest.lon], {{\n            radius: 12,\n            color: 'red',\n            fillColor: 'yellow',\n            fillOpacity: 0.9,\n            weight: 3,\n            className: 'selected-point'\n        }}).addTo(mapObj)\n          .bindPopup('Selected Grid Point<br>Lat: ' + nearest.lat.toFixed(4) + '<br>Lon: ' + nearest.lon.toFixed(4))\n          .openPopup();\n        \n        console.log('Grid point selected:', nearest.lat, nearest.lon);\n        \n        // Send coordinates to Flask app\n        fetch('/get_timeseries', {{\n            method: 'POST',\n            headers: {{\n                'Content-Type': 'application/json',\n            }},\n            body: JSON.stringify({{lat: nearest.lat, lon: nearest.lon}})\n        }})\n        .then(response => response.json())\n        .then(data => {{\n            console.log('Time series response:', data);\n            if (data.success) {{\n                if (typeof window.updateCharts === 'function') {{\n                    window.updateCharts(data.charts);\n                }}\n                // Update selected coordinates display\n                const coordsEl = document.getElementById('selectedCoords');\n                if (coordsEl) {{\n                    coordsEl.textContent = 'Selected point: ' + nearest.lat.toFixed(4) + ', ' + nearest.lon.toFixed(4);\n                }}\n            }} else {{\n                console.error('Time series error:', data.error);\n                alert('Error generating time series: ' + data.error);\n            }}\n        }}).catch(error => {{\n            console.error('Error fetching time series:', error);\n            alert('Network error: ' + error.message);\n        }});\n    }});\n    </script>\n    \"\"\"\n    \n    # Create MacroElement to inject the script\n    from branca.element import Template\n    macro = MacroElement()\n    macro._template = Template(click_script)\n    m.get_root().add_child(macro)\n    \n    return m\n\n\n@app.route('/')\ndef index():\n    \"\"\"Main page\"\"\"\n    return render_template('index.html')\n\n\n@app.route('/upload', methods=['POST'])\ndef upload_file():\n    \"\"\"Handle NetCDF file upload\"\"\"\n    global current_dataset, current_filename\n    \n    if 'file' not in request.files:\n        return jsonify({'success': False, 'error': 'No file provided'})\n    \n    file = request.files['file']\n    if file.filename == '':\n        return jsonify({'success': False, 'error': 'No file selected'})\n    \n    if file and file.filename and allowed_file(file.filename):\n        filename = secure_filename(file.filename)\n        filepath = os.path.join(app.config['UPLOAD_FOLDER'], filename)\n        file.save(filepath)\n        \n        # Extract NetCDF information\n        info = extract_netcdf_info(filepath)\n        if not info['success']:\n            return jsonify({'success': False, 'error': info['error']})\n        \n        # Load dataset\n        try:\n            current_dataset = xr.open_dataset(filepath)\n            current_filename = filename\n            \n            # Create coverage map\n            coverage_map = create_coverage_map(current_dataset)\n            if coverage_map:\n                map_html = coverage_map._repr_html_()\n            else:\n                map_html = None\n            \n            return jsonify({\n                'success': True,\n                'info': info,\n                'map_html': map_html\n            })\n        except Exception as e:\n            return jsonify({'success': False, 'error': f'Error loading dataset: {str(e)}'})\n    \n    return jsonify({'success': False, 'error': 'Invalid file type. Please upload a .nc file'})\n\n\n@app.route('/get_timeseries', methods=['POST'])\ndef get_timeseries():\n    \"\"\"Get time series data for selected coordinates\"\"\"\n    global current_dataset\n    \n    if current_dataset is None:\n        return jsonify({'success': False, 'error': 'No dataset loaded'})\n    \n    data = request.get_json()\n    if not data:\n        return jsonify({'success': False, 'error': 'No JSON data provided'})\n    \n    target_lat = data.get('lat')\n    target_lon = data.get('lon')\n    \n    if target_lat is None or target_lon is None:\n        return jsonify({'success': False, 'error': 'Coordinates not provided'})\n    \n    try:\n        # Find the nearest grid point\n        ds = current_dataset\n        \n        # Find latitude and longitude variable names\n        lat_var = None\n        lon_var = None\n        time_var = None\n        \n        for coord in ds.coords:\n            coord_lower = str(coord).lower()\n            if 'lat' in coord_lower:\n                lat_var = coord\n            elif 'lon' in coord_lower:\n                lon_var = coord\n            elif 'time' in coord_lower:\n                time_var = coord\n        \n        if not lat_var or not lon_var:\n            return jsonify({'success': False, 'error': 'Could not find latitude/longitude coordinates'})\n        \n        # Find nearest point\n        point = ds.sel({lat_var: target_lat, lon_var: target_lon}, method='nearest')\n        \n        charts = {}\n        \n        # Create time series for each data variable\n        for var_name in ds.data_vars:\n            var_data = point[var_name]\n            \n            # Skip if variable doesn't have time dimension\n            if time_var and time_var in var_data.dims:\n                # Extract time series data\n                times = var_data[time_var].values\n                values = var_data.values\n                \n                # Create plotly chart\n                fig = go.Figure()\n                fig.add_trace(go.Scatter(\n                    x=times,\n                    y=values,\n                    mode='lines+markers',\n                    name=var_name,\n                    line=dict(width=2)\n                ))\n                \n                var_title = str(var_name).title() if hasattr(var_name, 'title') else str(var_name).capitalize()\n                fig.update_layout(\n                    title=f'{var_title} Time Series',\n                    xaxis_title='Time',\n                    yaxis_title=f'{var_name} ({var_data.attrs.get(\"units\", \"\")})' if hasattr(var_data, 'attrs') else str(var_name),\n                    template='plotly_white'\n                )\n                \n                charts[var_name] = json.loads(plotly.utils.PlotlyJSONEncoder().encode(fig))\n        \n        return jsonify({\n            'success': True,\n            'charts': charts,\n            'coordinates': {'lat': float(point[lat_var].values), 'lon': float(point[lon_var].values)}\n        })\n        \n    except Exception as e:\n        return jsonify({'success': False, 'error': f'Error processing coordinates: {str(e)}'})\n\n\nif __name__ == '__main__':\n    app.run(host='0.0.0.0', port=5000, debug=True)","size_bytes":12965},"pyproject.toml":{"content":"[project]\nname = \"repl-nix-workspace\"\nversion = \"0.1.0\"\ndescription = \"Add your description here\"\nrequires-python = \">=3.11\"\ndependencies = [\n    \"flask>=3.1.2\",\n    \"folium>=0.20.0\",\n    \"netcdf4>=1.7.2\",\n    \"numpy>=2.3.3\",\n    \"pandas>=2.3.2\",\n    \"plotly>=6.3.0\",\n    \"werkzeug>=3.1.3\",\n    \"xarray>=2025.9.0\",\n]\n","size_bytes":317},"replit.md":{"content":"# NetCDF Weather Data Visualizer\n\n## Overview\n\nThis is a Flask-based web application designed to visualize weather and climate data from NetCDF files. The application allows users to upload NetCDF files through a drag-and-drop interface and provides interactive visualizations including maps, charts, and time series analysis. The tool is built to handle large climate datasets (up to 100MB) and extract coordinate and variable information for comprehensive data exploration.\n\n## User Preferences\n\nPreferred communication style: Simple, everyday language.\n\n## System Architecture\n\n### Frontend Architecture\n- **Technology Stack**: HTML5, Bootstrap 5, JavaScript, Plotly.js\n- **UI Components**: Drag-and-drop file upload interface with visual feedback states\n- **Visualization Libraries**: \n  - Plotly.js for interactive charts and time series plots\n  - Folium for interactive maps (server-side rendered)\n- **Responsive Design**: Bootstrap-based responsive layout for cross-device compatibility\n\n### Backend Architecture\n- **Framework**: Flask (Python web framework)\n- **File Handling**: Werkzeug for secure file upload processing\n- **Data Processing Pipeline**:\n  - xarray for NetCDF file reading and manipulation\n  - numpy for numerical computations\n  - pandas for data analysis and transformation\n- **Session Management**: Global variables for current dataset storage (development setup)\n- **File Storage**: Local filesystem uploads directory with security validation\n\n### Data Processing\n- **NetCDF Support**: Full xarray integration for reading multi-dimensional climate data\n- **Data Extraction**: Automatic coordinate and variable information extraction\n- **Coordinate Systems**: Support for spatial (lat/lon) and temporal dimensions\n- **Variable Analysis**: Dynamic detection of data variables with dimensional metadata\n\n### Security and Validation\n- **File Type Validation**: Restricted to .nc (NetCDF) files only\n- **File Size Limits**: 100MB maximum upload size\n- **Secure Filename Handling**: Werkzeug secure_filename for safe file processing\n- **Environment Configuration**: Environment-based secret key management\n\n## External Dependencies\n\n### Core Python Libraries\n- **Flask**: Web framework for application structure and routing\n- **xarray**: NetCDF file handling and multi-dimensional data processing\n- **numpy**: Numerical computing and array operations\n- **pandas**: Data manipulation and analysis\n\n### Visualization Dependencies\n- **Plotly**: Interactive charting and graphing (client-side JavaScript)\n- **Folium**: Interactive map generation with Leaflet.js backend\n- **Branca**: HTML/CSS/JavaScript generation for Folium maps\n\n### Frontend Dependencies\n- **Bootstrap 5**: CSS framework for responsive UI components\n- **Plotly.js**: Client-side JavaScript library for interactive visualizations\n\n### Development Dependencies\n- **Werkzeug**: WSGI utilities and secure file handling\n- **OS/JSON**: Standard library modules for system operations and data serialization","size_bytes":2986}},"version":1}